<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grand Neon Piano v2.9</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@tonejs/midi"></script>
    <script src="https://unpkg.com/tone"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000105; font-family: 'Pretendard', sans-serif; }
        canvas { display: block; filter: contrast(1.1) brightness(1.1); }
        
        .ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            pointer-events: none;
            z-index: 50;
        }
        
        .mode-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 50;
        }

        .playback-info {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 180px;
            padding: 8px 12px;
            background: rgba(0, 5, 15, 0.4);
            backdrop-filter: blur(8px);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            z-index: 60;
            opacity: 0;
            transform: translateY(-5px);
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .playback-info.active {
            opacity: 1;
            transform: translateY(0);
        }

        .progress-container {
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 1px;
            margin-top: 6px;
            overflow: hidden;
        }

        .progress-bar {
            width: 0%;
            height: 100%;
            background: #00f2fe;
            box-shadow: 0 0 5px rgba(0, 242, 254, 0.8);
        }

        .mode-toggle {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 9px;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .mode-toggle.active {
            background: rgba(0, 242, 254, 0.45);
            color: #fff;
            border-color: #00f2fe;
            box-shadow: 0 0 15px rgba(0, 242, 254, 0.2);
        }
        
        .data-monitor {
            position: absolute;
            right: 20px;
            top: 60px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 8px;
            color: #00f2fe;
            text-align: right;
            pointer-events: none;
            opacity: 0.3;
        }

        .upload-container {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 5, 15, 0.8);
            padding: 20px 40px;
            border-radius: 50px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 242, 254, 0.2);
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #file-label {
            cursor: pointer;
            background: linear-gradient(135deg, #00f2fe 0%, #005f73 100%);
            padding: 10px 30px;
            border-radius: 30px;
            color: #fff;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 12px;
        }

        .download-btn {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            background: #ffffff;
            color: #000;
            padding: 10px 25px;
            border-radius: 30px;
            font-weight: bold;
            font-size: 12px;
            cursor: pointer;
            display: none;
            z-index: 100;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
            border: none;
            transition: opacity 1s ease, transform 0.5s ease;
        }

        .download-btn.fade-out {
            opacity: 0;
            pointer-events: none;
            transform: translateX(-50%) translateY(10px);
        }

        .invisible-ui { opacity: 0 !important; transform: translateY(-10px); pointer-events: none !important; }
    </style>
</head>
<body>

<div id="main-logo" class="ui-panel">
    <h1 class="text-base font-black tracking-tighter italic leading-none">NEON<br><span class="text-cyan-400">PIANO</span></h1>
    <p class="text-[5px] mt-1 opacity-40 uppercase tracking-[0.3em]">Pure Octave Mapping V2.9</p>
</div>

<div id="mode-panel" class="mode-panel">
    <button id="mode-ai-rearrange" class="mode-toggle">OCTAVE BOOST (OFF)</button>
</div>

<div id="playback-panel" class="playback-info">
    <div class="flex justify-between items-center">
        <div class="overflow-hidden">
            <div id="now-playing-title" class="text-[9px] font-bold truncate w-[100px]">No File</div>
            <div class="text-[6px] text-cyan-400 font-bold uppercase tracking-widest opacity-60">Playing</div>
        </div>
        <div id="play-time" class="text-[8px] font-mono opacity-60 text-right">0:00</div>
    </div>
    <div class="progress-container">
        <div id="progress-bar" class="progress-bar"></div>
    </div>
</div>

<div id="monitor" class="data-monitor">
    [<span id="engine-status">STANDBY</span>]<br>
    FPS: <span id="fps-counter">60</span>
</div>

<div class="upload-container" id="uploader">
    <label id="file-label" for="midi-input">Inject MIDI</label>
    <input type="file" id="midi-input" accept=".mid, .midi" class="hidden">
    <div id="status-text" class="mt-2 text-[8px] font-medium text-cyan-400/40 uppercase tracking-widest text-center">
        Octave Doubling Engine Ready
    </div>
</div>

<button id="download-btn" class="download-btn">DOWNLOAD OCTAVE VERSION</button>

<canvas id="mainCanvas"></canvas>

<script>
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const midiInput = document.getElementById('midi-input');
    const statusText = document.getElementById('status-text');
    const uploader = document.getElementById('uploader');
    const fpsCounter = document.getElementById('fps-counter');
    const engineStatus = document.getElementById('engine-status');
    const downloadBtn = document.getElementById('download-btn');
    
    const mainLogo = document.getElementById('main-logo');
    const modePanel = document.getElementById('mode-panel');
    const playbackPanel = document.getElementById('playback-panel');
    const progressBar = document.getElementById('progress-bar');
    const playTimeText = document.getElementById('play-time');
    const nowPlayingTitle = document.getElementById('now-playing-title');
    const btnRearrange = document.getElementById('mode-ai-rearrange');

    let sampler, isPlaying = false, midiData = null, rearrangedMidi = null; 
    let currentFileName = "arrangement.mid", startTime = 0, totalDuration = 0, audioReady = false;
    let lastTime = performance.now(), frameCount = 0, fps = 0, currentMode = 'normal';
    let downloadHideTimer = null;

    const KEYBOARD_HEIGHT = 70;
    const START_MIDI = 21, END_MIDI = 108, WHITE_KEYS_COUNT = 52, FALL_DURATION = 2.5; 
    
    const keyStates = {};
    for (let i = START_MIDI; i <= END_MIDI; i++) {
        keyStates[i] = { intensity: 0, hue: 0, isWhite: false, active: false, velocity: 1.0 };
    }

    let particles = [];

    class Particle {
        constructor(x, y, hue, velocity, isAI = false) {
            this.x = x; this.y = y;
            this.vx = (Math.random() - 0.5) * (isAI ? 4 : 3) * velocity;
            this.vy = (-Math.random() * (isAI ? 6 : 4) - 2) * velocity;
            this.life = 1.0; this.hue = hue; this.isAI = isAI;
            this.size = (Math.random() * (isAI ? 1.5 : 1) + 0.5);
        }
        update() { this.x += this.vx; this.y += this.vy; this.vy += 0.25; this.life -= 0.03; }
        draw() {
            ctx.fillStyle = this.isAI ? `rgba(255, 255, 255, ${this.life})` : `hsla(${this.hue}, 100%, 70%, ${this.life})`;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
        }
    }

    function formatTime(seconds) {
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
    }

    btnRearrange.onclick = () => {
        currentMode = currentMode === 'rearrange' ? 'normal' : 'rearrange';
        btnRearrange.classList.toggle('active', currentMode === 'rearrange');
        btnRearrange.innerText = `OCTAVE BOOST (${currentMode === 'rearrange' ? 'ON' : 'OFF'})`;
    };

    async function callRearrangeAI(originalMidi) {
        engineStatus.innerText = "MAPPING_OCTAVES";
        return new Promise((resolve) => {
            setTimeout(() => {
                const rearranged = new Midi(originalMidi.toArray());
                rearranged.tracks.forEach((track) => {
                    const originalNotes = [...track.notes];
                    if (originalNotes.length === 0) return;
                    originalNotes.forEach((note) => {
                        note.isAI = false;
                        if (note.midi <= 48) {
                            track.addNote({
                                midi: note.midi - 12,
                                velocity: note.velocity * 0.45,
                                time: note.time,
                                duration: note.duration,
                                isAI: true
                            });
                        }
                        if (note.midi >= 60) {
                            track.addNote({
                                midi: note.midi + 12,
                                velocity: note.velocity * 0.35,
                                time: note.time,
                                duration: note.duration,
                                isAI: true
                            });
                        }
                    });
                });
                resolve(rearranged);
            }, 800);
        });
    }

    async function initSampler() {
        if (audioReady) return;
        statusText.innerText = "Loading Piano Samples...";
        sampler = new Tone.Sampler({
            urls: { A0: "A0.mp3", C1: "C1.mp3", "D#1": "Ds1.mp3", "F#1": "Fs1.mp3", A1: "A1.mp3", C2: "C2.mp3", "D#2": "Ds2.mp3", "F#2": "Fs2.mp3", A2: "A2.mp3", C3: "C3.mp3", "D#3": "Ds3.mp3", "F#3": "Fs3.mp3", A3: "A3.mp3", C4: "C4.mp3", "D#4": "Ds4.mp3", "F#4": "Fs4.mp3", A4: "A4.mp3", C5: "C5.mp3", "D#5": "Ds5.mp3", "F#5": "Fs5.mp3", A5: "A5.mp3", C6: "C6.mp3", "D#6": "Ds6.mp3", "F#6": "Fs6.mp3", A6: "A6.mp3", C7: "C7.mp3", "D#7": "Ds7.mp3", "F#7": "Fs7.mp3", A7: "A7.mp3", C8: "C8.mp3" },
            release: 2.0, baseUrl: "https://tonejs.github.io/audio/salamander/"
        }).toDestination();
        await Tone.loaded();
        audioReady = true;
    }

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);
    resize();

    function getNoteX(midi) {
        const whiteKeyWidth = canvas.width / WHITE_KEYS_COUNT;
        let whiteKeyCount = 0;
        for (let i = START_MIDI; i < midi; i++) {
            if (![1, 3, 6, 8, 10].includes(i % 12)) whiteKeyCount++;
        }
        const isBlack = [1, 3, 6, 8, 10].includes(midi % 12);
        return isBlack ? (whiteKeyCount * whiteKeyWidth) - (whiteKeyWidth * 0.33) : whiteKeyCount * whiteKeyWidth;
    }

    midiInput.onchange = async function() {
        if (!audioReady) await initSampler();
        const file = this.files[0];
        if (!file) return;
        
        // 새로운 파일 업로드 시 기존 타이머 및 버튼 상태 초기화
        clearTimeout(downloadHideTimer);
        downloadBtn.style.display = 'none';
        downloadBtn.classList.remove('fade-out');

        currentFileName = file.name;
        nowPlayingTitle.innerText = file.name;

        const reader = new FileReader();
        reader.onload = async (e) => {
            let midi = new Midi(e.target.result);
            if(currentMode === 'rearrange') {
                midi = await callRearrangeAI(midi);
                rearrangedMidi = midi;
            } else {
                rearrangedMidi = null;
            }

            midiData = midi;
            totalDuration = midi.duration;
            await Tone.start();
            Tone.Transport.cancel();
            
            isPlaying = true;
            startTime = Tone.now() + 0.8;
            
            mainLogo.classList.add('invisible-ui');
            modePanel.classList.add('invisible-ui');
            playbackPanel.classList.add('active');
            uploader.style.opacity = "0";
            uploader.style.pointerEvents = "none";
            
            midi.tracks.forEach(track => {
                track.notes.forEach(note => {
                    Tone.Transport.schedule((time) => {
                        sampler.triggerAttackRelease(note.name, note.duration, time, note.velocity);
                        createParticles(note.midi, note.velocity, note.isAI);
                    }, note.time + startTime);
                });
            });

            Tone.Transport.schedule(() => {
                setTimeout(() => {
                    isPlaying = false;
                    mainLogo.classList.remove('invisible-ui');
                    modePanel.classList.remove('invisible-ui');
                    playbackPanel.classList.remove('active');
                    uploader.style.opacity = "1";
                    uploader.style.pointerEvents = "auto";
                    
                    // 옥타브 변환 모드였을 경우에만 다운로드 버튼 표시
                    if(currentMode === 'rearrange') {
                        downloadBtn.style.display = 'block';
                        // 7초 후에 사라지는 타이머 시작
                        clearTimeout(downloadHideTimer);
                        downloadHideTimer = setTimeout(() => {
                            downloadBtn.classList.add('fade-out');
                            setTimeout(() => { downloadBtn.style.display = 'none'; }, 1000);
                        }, 7000);
                    }
                    engineStatus.innerText = "STANDBY";
                }, 1000);
            }, totalDuration + startTime);

            Tone.Transport.start();
            engineStatus.innerText = "PLAYING";
        };
        reader.readAsArrayBuffer(file);
    };

    downloadBtn.onclick = () => {
        if (!rearrangedMidi) return;
        const blob = new Blob([rearrangedMidi.toArray()], { type: "audio/midi" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `[OCTAVE_BOOST]_${currentFileName}`;
        a.click();
    };

    function createParticles(midi, velocity, isAI = false) {
        const x = getNoteX(midi) + (canvas.width / WHITE_KEYS_COUNT * 0.4);
        const hue = (midi * 13) % 360;
        const count = isAI ? 4 : Math.floor(3 + velocity * 4);
        for(let i=0; i<count; i++) {
            particles.push(new Particle(x, canvas.height - KEYBOARD_HEIGHT, hue, velocity, isAI));
        }
    }

    function updateKeyStates() {
        const currentTime = isPlaying ? Tone.Transport.seconds - startTime : -1;
        if(isPlaying && totalDuration > 0) {
            const elapsed = Math.max(0, currentTime);
            progressBar.style.width = `${Math.min(100, (elapsed / totalDuration) * 100)}%`;
            playTimeText.innerText = formatTime(elapsed);
        }

        for (let i = START_MIDI; i <= END_MIDI; i++) {
            let activeInFrame = false, currentVel = 0, nHue = (i * 13) % 360, nIsAI = false;
            if (midiData && currentTime >= 0) {
                midiData.tracks.forEach(t => { 
                    t.notes.forEach(n => {
                        if (n.midi === i && currentTime >= n.time && currentTime <= n.time + n.duration) {
                            activeInFrame = true; currentVel = n.velocity; nHue = (n.midi * 13) % 360; nIsAI = n.isAI;
                        }
                    });
                });
            }
            if (activeInFrame) {
                keyStates[i].intensity = 1.0; keyStates[i].hue = nHue;
                keyStates[i].isWhite = nIsAI; keyStates[i].active = true; keyStates[i].velocity = currentVel;
            } else {
                keyStates[i].active = false; 
                keyStates[i].intensity -= 0.03; 
                if (keyStates[i].intensity < 0) keyStates[i].intensity = 0;
            }
        }
    }

    function drawKeyboard() {
        const whiteKeyWidth = canvas.width / WHITE_KEYS_COUNT;
        const blackKeyWidth = whiteKeyWidth * 0.6;
        let whiteIdx = 0;
        for (let i = START_MIDI; i <= END_MIDI; i++) {
            const isBlack = [1, 3, 6, 8, 10].includes(i % 12);
            if (isBlack) continue;
            const x = whiteIdx * whiteKeyWidth;
            const state = keyStates[i];
            ctx.fillStyle = '#fefefe';
            ctx.fillRect(x, canvas.height - KEYBOARD_HEIGHT, whiteKeyWidth, KEYBOARD_HEIGHT);
            if (state.intensity > 0) {
                const alpha = state.intensity * (0.3 + state.velocity * 0.7);
                ctx.fillStyle = state.isWhite ? `rgba(255, 255, 255, ${alpha})` : `hsla(${state.hue}, 80%, 60%, ${alpha * 0.7})`;
                ctx.shadowColor = state.isWhite ? 'white' : `hsla(${state.hue}, 100%, 60%, 1)`;
                ctx.shadowBlur = 15 * state.intensity;
                ctx.fillRect(x, canvas.height - KEYBOARD_HEIGHT, whiteKeyWidth, KEYBOARD_HEIGHT);
                ctx.shadowBlur = 0;
            }
            ctx.strokeStyle = 'rgba(0,0,0,0.06)'; 
            ctx.strokeRect(x, canvas.height - KEYBOARD_HEIGHT, whiteKeyWidth, KEYBOARD_HEIGHT);
            whiteIdx++;
        }
        whiteIdx = 0;
        for (let i = START_MIDI; i <= END_MIDI; i++) {
            if ([1, 3, 6, 8, 10].includes(i % 12)) {
                const x = (whiteIdx * whiteKeyWidth) - (blackKeyWidth / 2);
                const state = keyStates[i];
                if (state.intensity > 0) {
                    const brightness = 10 + (state.velocity * 40 * state.intensity);
                    ctx.fillStyle = state.isWhite ? `rgba(255, 255, 255, ${state.intensity})` : `hsla(${state.hue}, 70%, ${brightness}%, 1)`;
                    ctx.shadowColor = state.isWhite ? 'white' : `hsla(${state.hue}, 100%, 60%, 1)`;
                    ctx.shadowBlur = 10 * state.intensity; 
                    ctx.fillRect(x, canvas.height - KEYBOARD_HEIGHT, blackKeyWidth, KEYBOARD_HEIGHT * 0.6); 
                    ctx.shadowBlur = 0;
                } else { 
                    ctx.fillStyle = '#111'; 
                    ctx.fillRect(x, canvas.height - KEYBOARD_HEIGHT, blackKeyWidth, KEYBOARD_HEIGHT * 0.6); 
                }
                ctx.strokeStyle = '#222'; 
                ctx.strokeRect(x, canvas.height - KEYBOARD_HEIGHT, blackKeyWidth, KEYBOARD_HEIGHT * 0.6);
            } else whiteIdx++;
        }
    }

    function drawFallingNotes() {
        if (!midiData || !isPlaying) return;
        const currentTime = Tone.Transport.seconds - startTime;
        const whiteKeyWidth = canvas.width / WHITE_KEYS_COUNT;
        midiData.tracks.forEach(track => {
            track.notes.forEach(note => {
                if (note.time + note.duration > currentTime && note.time < currentTime + FALL_DURATION) {
                    const isBlack = [1, 3, 6, 8, 10].includes(note.midi % 12);
                    const x = getNoteX(note.midi);
                    const width = isBlack ? whiteKeyWidth * 0.6 : whiteKeyWidth;
                    const y = (canvas.height - KEYBOARD_HEIGHT) - ((note.time - currentTime) / FALL_DURATION * (canvas.height - KEYBOARD_HEIGHT));
                    const height = (note.duration / FALL_DURATION) * (canvas.height - KEYBOARD_HEIGHT);
                    const hue = (note.midi * 13) % 360;
                    const grad = ctx.createLinearGradient(x, y - height, x, y);
                    if (note.isAI) {
                        grad.addColorStop(0, 'rgba(255, 255, 255, 0)');
                        grad.addColorStop(1, 'rgba(255, 255, 255, 0.5)');
                        ctx.shadowColor = 'white';
                    } else {
                        grad.addColorStop(0, `hsla(${hue}, 100%, 50%, 0)`);
                        grad.addColorStop(1, `hsla(${hue}, 100%, 60%, ${0.2 + note.velocity * 0.5})`);
                        ctx.shadowColor = `hsla(${hue}, 100%, 60%, 0.4)`;
                    }
                    ctx.fillStyle = grad;
                    if (currentTime >= note.time && currentTime <= note.time + note.duration) ctx.shadowBlur = 8;
                    ctx.beginPath(); ctx.roundRect(x + 1, y - height, width - 2, height, 2); ctx.fill(); ctx.shadowBlur = 0;
                }
            });
        });
    }

    function animate(now) {
        frameCount++;
        if (now - lastTime >= 1000) { fps = frameCount; frameCount = 0; lastTime = now; fpsCounter.innerText = fps; }
        ctx.fillStyle = '#000105'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        if (isPlaying) {
            drawFallingNotes();
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => { p.update(); p.draw(); });
        }
        updateKeyStates(); drawKeyboard();
        requestAnimationFrame(animate);
    }

    document.body.onclick = async () => { if (!audioReady) await initSampler(); };
    requestAnimationFrame(animate);
</script>
</body>
</html>